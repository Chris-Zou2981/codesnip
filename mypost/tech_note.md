# 前台

## Web 发展历史

Web设计初衷是一个静态信息资源发布媒介，通过超文本标记语言（HTML）描述信息资源，通过统一资源标识符（URI）定位信息资源，通过超文本转移协议（HTTP）请求信息资源。

用通俗的一点的话来说，客户端（一般为浏览器）通过URL找到网站(如www.google.com)，发出HTTP请求，服务器收到请求后返回HTML页面。

阶段

- Web 诞生
- 动态内容出现：CGI
- Web 编程脚本语言：PHP / ASP / JSP
- 分布式企业计算平台：J2EE / .NET
- 框架横飞的年代：MVC，ORM
- 回归 Web 本质：REST
- 浏览器的魔术：Ajax
- 前端MVC：Angular / Backbone
- Javascript 在服务端的逆袭：NodeJs

时间线

1. 1991年8月6日，Tim Berners Lee在alt.hypertext新闻组贴出了一份关于World Wide Web的简单摘要，标志了Web页面在Internet上的首次登场。
2. Berners Lee在1993年建立了万维网联盟（World Wide Web Consortium，W3C），负责Web相关标准的制定。
3. 1993年CGI（Common Gateway Interface）出现了，Web上的动态信息服务开始蓬勃兴起。
4. 于是1994年的时候，PHP诞生了，PHP可以把程序（动态内容）嵌入到HTML（模版）中去执行，不仅能更好的组织Web应用的内容，而且执行效率比CGI还更高。
5. 1995年NetScape公司设计的JavaScript被用作浏览器上运行脚本语言为网页增加动态性。
6. 之后96年出现的ASP和98年出现的JSP本质上也都可以看成是一种支持某种脚本语言编程（分别是VB和Java）的模版引擎。
7. 96年W3C发布了CSS1.0规范。CSS允许开发者用外联的样式表来取代难以维护的内嵌样式，而不需要逐个去修改HTML元素，这让HTML页面更加容易创建和维护。
8. Web开始广泛用于构建大型应用时，在分布式、安全性、事务性等方面的要求催生了J2EE(现在已更名为Java EE)平台在1999年的诞生，
9. 2000年随之而来的.net平台，其ASP.net构件化的Web开发方式以及Visual Stidio.net开发环境的强大支持，大大降低了开发企业应用的复杂度。
10. 2001年出现的Hibernate就是其中的佼佼者，已经成为Java持久层的规范JPA的主要参考和实现。
11. 比如2003年出现的Java开发框架Spring
12. 2004年出现的Struts就是当时非常流行的Java Web开发的MVC框架。
13. 2005年出现的AJAX这个概念使得JavaScript再次大放异彩。
14. 2004年出现的Ruby开发框架Rails
15. 2005出现的Python开发框架Django

参考链接

- [Web开发技术发展历史](https://www.tianmaying.com/tutorial/web-history)
- [Web开发技术的演变](http://blog.jobbole.com/45170/)



# 后台
# 数据库
# 网络
# 软件工程
## UML

### 类图

- 泛化: 泛化(generalization)：表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。
- 实现（Realization）:在类图中就是接口和实现的关系。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。
- 依赖(Dependency)：对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。
- 关联(Association) : 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。
- 聚合(Aggregation) : 表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。
- 组合(Composition) : 表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。

参考

- [UML类图与类的关系详解](http://www.uml.org.cn/oobject/201104212.asp)

## 需求工程



### 需求分类

软件需求包括3个不同的层次――业务需求、用户需求和功能需求。除此之外，每个系统还有各种非功能需求。 

- **业务需求**（Business requirement）表示组织或客户高层次的目标。业务需求描述了组织为什么要开发一个系统，即组织希望达到的目标。
- **用户需求**（user requirement）描述的是用户的目标，或用户要求系统必须能完成的任务,用户能使用系统来做些什么。用例、场景描述和事件都是表达用户需求的有效途径。 
- **功能需求**（functional requirement）规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。如“系统应该发送电子邮件来通知用户已接受其预定”。
- **系统需求**（system requirement）用于描述包含多个子系统的产品（即系统）的顶级需求。系统可以只包含软件系统，也可以既包含软件又包含硬件子系统
- **非功能需求** 为满足用户业务需求而必须具有且除功能需求以外的特性
  - 安全性
  - 可靠性
  - 易用性
  - 可维护性
  - 可移植性

### 需求开发



需求开发活动包括以下几个方面：

1. 确定用户分类
2. 获取每类用户的需求
3. 了解实际用户任务和目标
4. 分析源于用户的信息以获取用户任务需求、功能需求、业务规则、质量属性、建议解决方法和附加信息
5. 将系统级的需求分为几个子系统
6. 了解相关质量属性的重要性
7. 商讨实施优先级的划分
8. 编写成规格说明和模型。
9. 评审需求规格说明


### 用例描述

用例图描述了参与者要求系统能“做什么”，但是缺乏描述系统该“怎么做”的细节。一般情况下，每个用例应具有一个用例描述。

#### 用例描述说明



- **用例名称**：用例名称应该表明用户的意图或用例的用途，例如：借阅图书、归还图书、预定图书等。
- **用例编号**： UC 0001
- **简要说明**：对用例进行简要说明，描述该用例的作用，说明应当简明扼要。
- **参与者**：与此用例相关的参与者列表
- **前置条件**：执行用例之前系统必须满足的条件，例如：当学生借阅图书时，借阅图书用例需要获取学生的借阅证信息，如果学生使用了一个已经被注销的借阅证，那么借阅图书用例就不能执行。
- **后置条件**：后置条件将在用例成功完成以后得到满足，它提供了系统的部分描述。例如：当学生借阅图书成功后，借阅图书用例应该提供该学生的所有借阅信息。
- **基本操作流程**：指参与者在用例中所遵循的主逻辑路径。例如，借阅图书用例的基本操作流程如下：
  - (1) 图书管理员输入借阅证信息
  - (2) 系统检查读者是否有超期的借阅信息
  - (3) 系统检查读者的借书数量是否已经达到借书限额
  - (4) 图书管理员输入要借阅的图书信息
  - (5) 系统将读者的借阅信息保存到数据库中
- **可选操作流程**：指参与者在用例中所遵循的次逻辑路径，通常是指出现异常或发生错误的情况下所遵循的路径。
- **涉及数据**：填写该用例涉及的相关信息，如图书名字，价格，ISBN号，出版日期等

#### 完整用例示例



| 主执行者      | 请求者                                      |
| --------- | ---------------------------------------- |
| 语境中的目标    | 请求者通过系统买东西，并得到说买的东西。不包括付款方面的内容。          |
| 范围        | 业务——整个购买机制，包括电子的和非电子的，正如人们在公司中说见到的一样。    |
| 层次        | 概要                                       |
| 项目相关人员和利益 | 请求者：希望得到她订购的东西，并且操作要简单。公司：希望控制花费，但允许必要的购买。供货商：希望得到任何已发货物的货款。 |
| 前置条件      | 无                                        |
| 最小保证      | 每一个发出的订单都已经获得有效认证者的许可。订单具有可跟踪性，以便公司只对收到的有效货物开账单。 |
| 成功保证      | 求者得到货物，修改预算，记入借方。                        |
| 触发事件      | 请求者决定买东西。                                |
| 主成功场景     | 1. 请求者：发起一个请求。2.   批准者：检查预算中的资金，检查货物的价格，完成提交请求。3. 买者：检查仓库的存货，找出最好的供货商。4. 认证者：验证批准者的签名。5. 买者：完成订购请求，向供货商发出PO（订单）。6. 供货商：把货物发送给接收者，得到发货收据（这一点超出了本系统的设计范围）。7. 接收者：记录发货情况；向请求者发送货物。8. 请求者：设置请求已被满足标志。 |
| 扩展        | 1a）请求者不知道供货商和货物价格：不填写这些内容，然后继续。1b）在收到货物之前的任意时刻，请求者都可以修改或取消请求：如果取消，则把这个请求从执行处理中取消。（从系统中删除吗？）如果降低价格，则不影响其处理过程。如果提高价格，则把请求送回批准者。2a）批准者不知道供货商或货物价格：不填写这些内容，留待买者填写或返回。2b）批准者不是请求者的经理：只是批准者签名仍然可行。2c）批准者拒绝申请：送回给请求者，要其修改或删除。3a）买者在仓库中找到货物：将存货先发出，并从申请者要求的总购买者中减去已经发出的这部分货物量，然后继续。3b）买者填写在前面活动中没有填写的供货商和价格信息：请求重新发回给批准者。4a）认证者拒绝批准者：发回请求者，并将此请求从执行处理中取消。5a）请求涉及到多个供货商：买者创建多个PO5b）买者将多个请求合并：相同的过程，但是用被合并的请求标记PO6a）供货商没有按时发货：系统发出没有发货警告。7a）部分发货：接收者在PO上做部分发货标记，然后继续。7b）多个请求PO的部分发货：接收者给每个请求分配货物数量，然后继续。8a）货物不对或质量不合格：请求者拒绝接收所发送的货物。8b）请求者已经离开公司：买者同请求者的经理进行核实，或者重新指派申请者，或者返还货物并取消请求。 |
| 技术和数据变动列表 | 无                                        |
| 优先级       | 多种                                       |
| 发行版本      | 几个                                       |
| 响应时间      | 多样                                       |
| 使用频率      | 3/天                                      |
| 主执行者的渠道   | 网络浏览器、邮件系统或类似系统                          |
| 次要执行者     | 供货商                                      |
| 次要执行者的渠道  | 传真、电话或汽车                                 |
| 未解决的问题    | 什么时候从系统中删除被取消的请求？要取消一个请求需要那些权限？谁能修改一个请求的内容？请求中需要保留哪些修改历史记录？当请求者拒绝已经发送的货物时，会发生什么情况？申请和订货在运作上有什么不同？ 订购如何参考和使用内部存货？ |

#### 用例执行步骤的10大准则

（1）使用简单的语法；
句子结构应该非常简单：主语……谓语动词……直接宾语……前置短语
例如                  系统……从帐户余额中扣除……一定数量……

（2）明确地写出“谁控制球”；
作者举了踢足球的场景的例子，说明了不管步骤的执行者如何变化，都要遵循（1）描述的格式。

（3）从俯视的角度来编写用例；
从用户的角度来写用例，而不是从系统内部来描述系统

~~（4）显示过程向前推移；~~

（5）显示执行者的意图而不是动作；
通过操纵系统的用户界面来描述用户的动作，这是在编写用例时常见的一种严重错误，它使得编写的目标处于一个很低的层次。我把它叫做“界面细节描述（interface detail description）”。在需求文档中，我们只关心界面所要达到的意图，总结在执行者之间传递的信息。可将这些低层次的步骤合并成一个步骤。

~~（6）包含“合理”的活动集；~~

（7）“确认”而不是“检查是否”
这是一个经常犯的错误，写用例不是写程序流程，不需要用选择语法，需要选择的时候，在扩展场景里体现

（8）可选择地提及时间限制；

（9）习惯用语：“用户让系统A与系统B交互”；
要分开来写，用户与系统A怎么怎么样，然后系统A和系统B怎么怎么样，这样用户才能看的懂。

（10）习惯用语：“循环执行步骤X到Y，直到条件满足”；
同（7），但如果需要重复的话，可直接在重复的步骤的前面和后面说明即可。

总之，这10大原则，目的就是为了让用例成为用户和开发人员沟通的桥梁，所以语言要简单易懂，而且要逻辑清晰。

### 参考链接



- [需求入门： 需求工程＝需求开发＋需求管理](http://www.uml.org.cn/RequirementProject/201005285.asp)
- [软件需求规格说明书模板](https://jingyan.baidu.com/article/6dad5075eae10da123e36e80.html)
- [描述用例](http://blog.csdn.net/wlanye/article/details/7445676)
- [软件需求3个层次――业务需求、用户需求和功能需求](https://www.cnblogs.com/litian/articles/2047981.html)
- [非功能性六大点](https://jingyan.baidu.com/article/90bc8fc80960f1f653640ce0.html)
- [《编写有效用例》学习笔记](http://lib.csdn.net/article/softwaretest/24322)





## 文档

### 文档列表

1. 可行性分析报告
2. 项目开发计划
3. **软件需求说明书**
4. **概要设计说明书**
5. 详细设计说明书
6. **用户操作手册、运维部署文档**
7. 测试计划
8. 测试分析报告
9. 开发进度月报
10. 项目开发总结报告
11. 软件维护手册
12. 软件问题报告
13. 软件修改报告 

### 需求分析文档

内容

- 项目背景
- 使用角色
- 功能需求
  - 功能划分
  - 用例图
  - 用例描述
- 性能需求
  - 用户数评估
  - 响应时间要求
  - 可靠性需求
- 用户界面

### 概要设计文档

对大部分的公司来说，概要设计文档是唯一的设计文档，对后面的开发、测试、实施、维护工作起到关键性的影响。

内容

- 功能介绍
  - 用例图
- 整体架构
  - 层次结构
  - 模块划分
  - 模块间调用关系
  - 包图、组件图
- 接口设计
  - 对外接口草案
  - 模块间接口草案
- 模块设计
  - 职责描述
  - 类图
  - 算法描述（如有）
- 数据流设计
  - 流程图
  - 序列图
  - 状态图
- 数据库概要设计
  - 表设计
  - 核心语句
- 主要界面
- 部署结构
  - 部署图
- 非功能需求
  - 性能需求
  - 安全需求
  - 扩展性需求
- 编码规范
  - 代码风格
  - 数据库命名规范
  - 接口规范

### 详细设计文档

同概要设计文档，只是需要更详细，比如

- 类图要精确到字段，方法的类型，
- 数据库设计要精确到字段类型，索引设计
- 核心算法要画出序列图及伪代码

### 运维部署文档

内容

- 硬件需求
- 软件需求
- 外部依赖
- 部署步骤
- 配置说明
- 维护命令：启动、停止、重启
- 监控指标
- 如何升级
- 常见问题处理
- 数据备份

### 参考链接

- [软件开发文档范例](http://zz563143188.iteye.com/blog/1835305)
- [概要设计文档编写规范](http://blog.csdn.net/nengyu/article/details/3758312)

# 工具

## 编辑器



### 功能需求



- 行号显示
- 语法高亮
- 自动识别编码
- 自动缩进
- 智能提示
- 列编辑
- 代码片段
- 代码折叠
- 新建文件模板
- 多标签
- 会话管理
- 分屏
- 书签
- 多次光标点跳转

### VS Code

快捷键

- 注释切换：ctrl +／
- 格式化代码： Alt + Shift + F
- 自动换行：Alt + Z
- 选区移动：Alt + ↑/↓
- 多选修改：Ctrl + D

参考链接：

- [为什么我选择使用 VS Code进行前端开发?](https://zhuanlan.zhihu.com/p/28631442)
- [TextMate代码片段语法](https://manual.macromates.com/en/snippets)

# 物联网

## 硬件技术

### RFID

从概念上来讲，RFID类似于[条码扫描](https://baike.baidu.com/item/%E6%9D%A1%E7%A0%81%E6%89%AB%E6%8F%8F)，对于条码技术而言，它是将已编码的条形码附着于目标物并使用专用的扫描读写器利用光信号将信息由条形磁传送到扫描读写器；而RFID则使用专用的RFID读写器及专门的可附着于目标物的RFID标签，利用频率信号将信息由RFID标签传送至RFID读写器。

[射频识别系统](https://baike.baidu.com/item/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F)最重要的优点是非接触识别，它能穿透雪、雾、冰、[涂料](https://baike.baidu.com/item/%E6%B6%82%E6%96%99)、[尘垢](https://baike.baidu.com/item/%E5%B0%98%E5%9E%A2)和条形码无法使用的恶劣环境阅读标签，并且阅读速度极快，大多数情况下不到100毫秒。

一维条形码的容量是50Bytes，二维条形码最大的容量可储存2至3000字符，RFID最大的容量则有数MegaBytes.

现今的条形码印刷上去之后就无法更改，RFID标签则可以重复地新增、修改、删除RFID卷标内储存的数据，方便信息的更新。

### NFC

NFC近场通信技术是由非接触式[射频识别](https://baike.baidu.com/item/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB)（[RFID](https://baike.baidu.com/item/RFID)）及互联互通技术整合演变而来，在单一芯片上结合感应式[读卡器](https://baike.baidu.com/item/%E8%AF%BB%E5%8D%A1%E5%99%A8)、感应式卡片和点对点的功能，能在短距离内与兼容设备进行识别和[数据交换](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2)。

NFC手机内置NFC芯片，比原先仅作为标签使用的RFID更增加了数据双向传送的功能，这个进步使得其更加适合用于电子货币支付的；

NFC传输范围比RFID小，RFID的传输范围可以达到几米、甚至几十米，但由于NFC采取了独特的信号衰减技术，相对于RFID来说NFC具有距离近、带宽高、能耗低等特点。

应用方向不同。NFC看更多的是针对于消费类电子设备相互通讯，有源RFID则更擅长在长距离识别。

NFC的短距离通信特性正是其优点，由于耗电量低、一次只和一台机器链接，拥有较高的保密性与安全性，NFC有利于信用卡交易时避免被盗用。

### PLC

